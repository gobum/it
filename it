#!/usr/bin/env node --harmony-async-iteration

/**
 * tagof(any): string
 *   获取任意值的标签
 */
var tagof = function(toString, reTag){
  return function(any) {
    return toString.call(any).match(reTag)[1];
  }
}(Object.prototype.toString, /\[object ([^\]]+)/);

/** -----------------------------------------------------------------------------------------------
 * go.js
 *   An asynchronous driver for generator.
 *   author: leadzen（李战）
 */
var go = function (toString, reIsGenerator) {
  function go(any) {
    return isGenerator(any)
      ? Promise.resolve().then(next)
      : Promise.resolve(any);

    function next(value) {
      return Promise.resolve(any.next(value))
        .then(function (state) {
          value = go(state.value);
          return state.done ? value : value.then(next);
        });
    }
  }

  return Object.defineProperties(go, {
    all: {
      value(iterable) {
        return Promise.all(function* (iterable) {
          for (var value of iterable) {
            yield go(value);
          }
        }(iterable));
      }
    },

    race: {
      value(iterable){
        return Promise.race(function* (iterable) {
          for (var value of iterable) {
            yield go(value);
          }
        }(iterable));
      }
    }
  });

  function isGenerator(any) {
    return reIsGenerator.test(toString.call(any));
  }
}(
  Object.prototype.toString,        // toString
  /\[object (?:Async)?Generator\]/  // reIsGenerator
);

/** -----------------------------------------------------------------------------------------------
 * promise.js
 */

(function (prototype, define) {
  if (!prototype.finally) {
    define(prototype, {
      finally: {
        value(onFinally) {
          return this.then(
            function (value) {
              onFinally();
              return value;
            },
            function (error) {
              onFinally();
              throw error;
            }
          );
        }
      }
    });
  }
})(Promise.prototype, Object.defineProperties);
var indent = function (regexp) {
  return function (text, dent) {
    text = String(text);
    dent = dent | 0;
    if (dent > 0) {
      text = text.replace(regexp, " ".repeat(dent));
    }
    else if (dent < 0) {
      dent = RegExp("^ {1," + -dent + "}", "gm");
      text = text.replace(dent, "");
    }
    return text;
  }
}(/^/gm);

var dentof = function (regexp) {
  return function (text) {
    text = String(text);
    var dents = text.match(regexp);
    return dents
      ? dents.reduce(function (min, str) {
        return (str = str.length) < min ? str : min;
      }, text.length)
      : 0;
  }
}(/^ *(?=\S)/gm);


/** -----------------------------------------------------------------------------------------------
 * print.js for nodejs
 */

var print = function (format, recolors, colors) {
  return function print(args, dent) {
    args = format.apply(undefined, args);

    args = args.replace(recolors, function (s, id) {
      return colors[id];
    }) + colors[0];

    args = indent(args, dent);

    console.log(args);
  }
}(
  /* format: */ require("util").format,
  /* recolors: */ /#([rgybmcs0#])/g,
  /* colors: */ {
    0: "\x1b[0m",   // RESET
    r: "\x1b[31m",  // red
    g: "\x1b[32m",  // green
    y: "\x1b[33m",  // yellow
    b: "\x1b[34m",  // blue
    m: "\x1b[35m",  // magenta
    c: "\x1b[36m",  // cyan
    s: "\x1b[90m",  // silver
    "#": "#"        // ESCAPE
  }
);


var nop = Function.prototype;
/** -----------------------------------------------------------------------------------------------
 * trace.js
 *   代码定位信息
 */

var tracehead = function (reWhere, reHere) {
  return function _where_(deep) {
    var stack = Error().stack.split("\n"), ms;
    for (var i = 0, line; line = stack[i++];) {
      if (line.match(reWhere)) break;
    }
    if (i < stack.length && (ms = String(stack[i + deep]).match(reHere))) {
      return {
        file: ms[1],
        row: ms[2] - 1
      };
    }
  };
}(
  /* reWhere: */ /\b_where_\b/,
  /* reHere: */ /((?:https?:\/\/[\w.-]+(?::\d+)?|)[\w./@-]+(?:\?.*|)):(\d+):(\d+)/
);

function tracetail(file, row) {
  var reFile = RegExp(file + ":(\\d+):(\\d+)");
  var stack = Error().stack.split("\n"), ms;
  for (var i = 0, line; line = stack[i++];) {
    if (ms = line.match(reFile)) {
      if (ms[1] > row) {
        return { row: ms[1]-1 };
      }
    }
  }
}



/** -----------------------------------------------------------------------------------------------
 * src.js
 */

var src = function(fs) {
  return function(file, head, tail) {
    var source;
    var rows = getrows(file);
    if(rows) {
      source = rows.slice(head, tail).join("\n");
      source = indent(source, -dentof(source));
    }
    return source || "<codeless>";
  }

  function getrows(file) {
    var rows;
    if (file in getrows) {
      rows = getrows[file];
    }
    else {
      rows = getrows[file] = get(file).split("\n");
    }
    return rows;
  }
  
  function get(file) {
    try {
      file = fs.readFileSync(file, "utf-8");
    }
    catch(e) {
      file = "";
    }
    return file;
  }
    
}(require("fs"));


/** -----------------------------------------------------------------------------------------------
 * assert.js
 *   原始断言类
 */

var Assert = function (setPrototype) {

  function Assert(args) {
    return setPrototype({
      any: args[0],
      topic: "",
      _not: 0,
      args: args,
      head: tracehead(2),
      state: 0
    }, it_proto);
  }

  Assert.prototype = {
    get desc() {
      return this.topic || this.source;
    },

    get source() {
      var head = this.head;
      if (head) {
        var file = head.file;
        head = head.row;
        var tail = tracetail(file, head);
        if (tail) {
          tail = tail.row;
        }
        else {
          tail = head + 1;
        }
        if (tail <= head) {
          tail = head + 1;
        }
        return src(file, head, tail);
      }
      return "<codeless>";
    },

    report() {
      var state = this.state;
      var desc = indent(this.desc, 2).trim();
      if (state > 0) {
        desc = "#g√ " + desc;
      }
      else if (state < 0) {
        desc = "#r☓ " + desc;
        if (this.reason) {
          desc += "\n#s" + indent(this.reason, 2);
        }
      }
      else {
        desc = "#y⚠ " + desc;
      }
      it.job.log(desc);
    },

    settle() {
      this.report();
    },

    get not() {
      this._not = !this._not;
      return Object.setPrototypeOf(this, Assert.prototype); 
    }
  }

  var it_proto = Object.setPrototypeOf({
    settle() {
      var args = this.args;
      if (args.length === 1) {
        this.state = args[0] ? 1 : -1;
      }
      else if (typeof args[1] === "function") {
        this.topic = args[0];
        try {
          args[1]();
          this.state = 1;
        }
        catch (error) {
          this.state = -1;
          this.reason = error && error.mesage || error;
        }
      }
      this.report();
    }
  }, Assert.prototype);

  Assert.define = function (props) {
    Object.defineProperties(Assert.prototype, Object.getOwnPropertyDescriptors(props));
  };

  return Assert;
}(Object.setPrototypeOf);

(function () {
  var typenames = ["undefined", "boolean", "number", "string", "symbol", "object", "function"];

  function assert_typeof(assert, typename) {
    if(!~typenames.indexOf(typename)) {
      throw Error('Unknown type name: "'+typename+'"');
    }
    assert.state = typeof assert.any === typename && !this._not ? 1 : -1;
    assert.report();
  }

  var type_of_any = {};

  for(typename of typenames) {
    Object.defineProperty(type_of_any, typename, {
      get: getter_of(typename)
    })
  }

  function getter_of(typename) {
    return function() {
      assert_typeof(this, typename);
    }
  }

  Assert.define({
    // it().typeof
    get typeof() {
      return proxify(
        function (typename) {
          assert_typeof(this, typename);
        },
        Object.setPrototypeOf(this, Assert.prototype),
        type_of_any
      );
    },

    // it().type.of
    get type() {
      var me = Object.setPrototypeOf(this, Assert.prototype);
      return {
        get of() {
          return proxify(
            function (typename) {
              assert_typeof(me, typename);
            },
            me,
            type_of_any
          );
        }
      }
    }
  });

})();
(function(){
  var types = [Object, Function, String, RegExp, Array, Boolean, Number, Date, Symbol, Error,
    Promise, Map, Set, WeakMap, WeakSet, Proxy,
    ArrayBuffer, DataView, Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array,
    Float32Array, Float64Array, 
    EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError];

  function assert_instanceof(assert, type) {
    assert.state = assert.any instanceof type && !this._not ? 1 : -1;
    assert.report();
  }

  var instance_of_any = {
  };

  for(type of types) {
    Object.defineProperty(instance_of_any, type.name, {
      get: getter_of(type)
    })
  }

  function getter_of(type) {
    return function() {
      assert_instanceof(this, type);
    }
  }

  function asserter_of(assert) {
    return proxify(
      function(type) {
        assert_instanceof(assert, type);
      },
      assert,
      instance_of_any
    )
  }

  Assert.define({
    // it().instanceof
    get instanceof() {
      Object.setPrototypeOf(this, Assert.prototype);
      return asserter_of(this);
      // return proxify(
      //   function(type) {
      //     assert_instanceof(this, type);
      //   },
      //   Object.setPrototypeOf(this, Assert.prototype),
      //   instance_of_any
      // );
    },

    // it().instance.of
    get instance() {
      var me = Object.setPrototypeOf(this, Assert.prototype);
      return {
        of: asserter_of(this) 
        // get of() {
        //   return 
          // return proxify(
          //   function(type) {
          //     assert_instanceof(me, type);
          //   },
          //   me,
          //   instance_of_any        
          // );
        // }
      }
    }
  });

})();
function proxify(proxy, self, proto) {
  var proto = Object.getOwnPropertyDescriptors(proto);
  var props = {};
  for (var key in proto) {
    var prop = proto[key];
    if (typeof prop.value === "function") {
      props[key] = {value: prop.value.bind(self)};
    }
    else if (prop.get || prop.set) {
      props[key] = {
        get: prop.get && prop.get.bind(self),
        set: prop.set && prop.set.bind(self)
      }
    }
  }
  return Object.defineProperties(proxy, props);
}


(function () {

  var is_any = Object.setPrototypeOf({
    get null() {
      this.state = this.any === null && !this._not ? 1 : -1;
      this.report();
    },
    get undefined() {
      this.state = this.any === undefined && !this._not ? 1 : -1;
      this.report();
    },
    get ok() {
      this.state = this.any && !this._not ? 1 : -1;
      this.report();
    },
    get true() {
      this.state = this.any === true && !this._not ? 1 : -1;
      this.report();
    },
    get false() {
      this.state = this.any === false && !this._not ? 1 : -1;
      this.report();
    },
    get boolean() {
      this.state = typeof this.any === "boolean" && !this._not ? 1 : -1;
      this.report();
    },
    get number() {
      this.state = typeof this.any === "number" && !this._not ? 1 : -1;
      this.report();
    },
    get string() {
      this.state = typeof this.any === "string" && !this._not ? 1 : -1;
      this.report();
    },
    get symbol() {
      this.state = typeof this.any === "symbol" && !this._not ? 1 : -1;
      this.report();
    },
    get object() {
      var any = this.any;
      this.state = any && ( typeof any === "object" || typeof any === "function" ) && !this._not ? 1 : -1;
      this.report();
    },
    get function() {
      this.state = typeof this.any === "function" && !this._not ? 1 : -1;
      this.report();
    },
}, Assert.prototype);

  Assert.define({
    get is() {
      return Object.setPrototypeOf(this, is_any);
    }
  });
})();


/** -----------------------------------------------------------------------------------------------
 * it.js
 *   测试驱动框架
 */

var it = (function () {
  function it(any) {
    return it.job.settle().assert = Assert(arguments);
  }

  it.do = it.does = function (topic, job) {
    it.job.settle();
    if (typeof job === "function") {
      Job(job, topic);
      it.job.add(job);

      return tagof(job) === "Function"
        ? {
          then(func) {
            job.callback = Job(func, job);
            return { in: job.in };
          }
        }
        : { in: job.in };
    }
  }

  it.log = function () {
    var job = it.job;
    job.settle();
    job.log.apply(undefined, arguments);
  };

  it.delay = function (time, value) {
    it.job.settle();
    return new Promise(function (resolve) {
      setTimeout(resolve, time, value);
    });
  };

  function Job(job, topic) {
    var dent = job.dent = job === it ?  0 : it.job.dent + 2;
    var jobs = [];
    var totalJobs = 0;
    var asserts = [];
    var time = 0;
    job.add = add;
    job.run = run;
    job.jobs = runs;
    job.log = log;
    job.in = function (_time) { time = _time };
    job.assert = null;
    job.settle = settle;

    return job;

    function add(job) {
      return jobs[totalJobs++] = job;
    }

    function runs() {
      var job = it.job, i = 0;
      return Promise.resolve().then(function next(job) {
        if (job = jobs[i++]) {
          return job.run()
            .then(next);
        }
      }).finally(function () {
        it.job = job;
      });
    }

    function run() {
      var promise = new Promise(function (resolve, reject) {
        out(topic);
        it.job = job;
        if (job.callback) {
          job(resolve, reject);
        }
        else {
          resolve(go(job()));
        }
      });

      if (time) {
        var timeout;
        promise = Promise.race([
          promise.finally(function () {
            clearTimeout(timeout);
          }),
          new Promise(function (resolve, reject) {
            timeout = setTimeout(reject, time, Error("Timeout " + time + "ms!"));
          })
        ]);
      }

      promise = promise.finally(settle);
      if (job.callback) {
        promise = promise.then(job.callback);
      }
      promise = promise.finally(settle);
      promise = promise.catch(function (error) {
        log("#m⦸ %s", error && error.message || error);
      }).then(runs);
      if (job.callback) {
        promise = promise.then(job.callback.jobs);
      }
      return promise;
    }

    function out() {
      print(arguments, dent-2);
    }
    
    function log() {
      print(arguments, dent);
    }

    function settle() {
      var assert = job.assert;
      if (assert) {
        if (!assert.state) {
          assert.settle();
        }
        job.assert = null;
      }
      return job;
    }
  }

  return Job(it.job = it);
})();


/** -----------------------------------------------------------------------------------------------
 * it
 */
var path = require("path");

var files = process.argv.slice(2);
if (files.length) {
  global.it = it;   // root it
  global.describe = it.does;
  it.jobs();
  
  files.map(function (file) {
    file = path.resolve(file);
    file = path.relative(__dirname, file);
    if (/^[^./]/.test(file)) {
      file = "./" + file;
    }
    require(file);
  });
}
